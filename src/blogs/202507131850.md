---
title: "Building a New GitOps Workflow for My Homelab: An Experiment"
date: "2025-07-13"
author: "Subhasis Bose"
summary: "In this post, I'm kicking off a new experiment to build a robust GitOps workflow for my personal homelab. I'll walk you through my motivation for tackling my lab's growing complexity and my plan for creating a safer, more predictable deployment process. I've detailed the Kustomize-inspired repository structure I'm starting with and the three-branch Git strategy I'll be using to move changes from development to production. Follow along as I see how it all turns out."
tags: ["GitOps", "Homelab", "Kubernetes", "CI/CD", "Automation", "DevOps", "Infrastructure as Code", "Kustomize", "GitHub Actions"]
category: "Setup"
image: "/blog-images/202507131850/GitOps.webp"
---

# Building a New GitOps Workflow for My Homelab: An Experiment

Hey everyone,

If you're anything like me, your homelab is a passion project—a place to learn, tinker, and maybe run a few useful services for yourself. But as my own lab has grown, I've found myself spending more time managing the complexity than actually innovating. It's time for a change.

So, I'm starting a new experiment: to build a robust, streamlined GitOps workflow from the ground up, tailored specifically for my homelab. My motivation is to create a system that's not just automated but also safe and predictable, allowing me to deploy changes with confidence.

I'm documenting the plan here as I go. Honestly, I'm not 100% sure how it will all turn out. Will it be the perfect solution, or will I hit roadblocks I haven't anticipated? Let's find out together!

### The Foundation: Repository Structure

Before diving into the branching, I need a solid directory structure. I'm going with a Kustomize-inspired layout to keep a clean separation between infrastructure, applications, and different environments. The plan is to structure it like this:

```
homelabs/
├── .github/
│   └── workflows/          # GitHub Actions for CI/CD pipelines
│
├── infrastructure/         # Infrastructure-as-Code (e.g., Talos configs)
│   ├── base/               # Common infrastructure definitions
│   └── overlays/           # Environment-specific configurations
│       ├── production/
│       └── testing/
│
├── apps/                   # Kubernetes application manifests
│   ├── base/               # Base manifests for applications
│   └── overlays/           # Environment-specific overrides
│       ├── production/
│       └── testing/
│
└── README.md
```

### The Theory: A Three-Branch Strategy & Workflow

The core of my proposed workflow revolves around three types of Git branches, all working together in a specific flow. Here's a diagram of how I envision it working:

<pre class="mermaid">
graph TD
    subgraph "Feature Development"
        A(Start: New Idea) --> B{Create feat/my-feature branch};
        B --> C(Develop & Push Changes);
    end

    subgraph "Testing Cluster"
        C --> D[Pipeline deploys to<br>Temporary Preview Environment];
        D --> E{Manual Verification};
        E -- Approved --> G;
        E -- Rejected --> C;
    end
    
    subgraph "Integration & Staging"
        G(Merge to develop) --> H[Pipeline cleans up Preview Env];
        H --> I[Pipeline deploys to<br>Main Testing Environment];
        I --> J{Manual Verification};
        J -- Rejected --> B;
    end

    subgraph "Production"
        J -- Approved --> K(Merge to main);
        K --> L[Pipeline deploys to<br>Production Environment];
        L --> M(End: Feature is Live);
    end
</pre>

### How It *Should* Work in Practice

As the diagram shows, the process is:

1.  **The `feat` Branch:** Every new change starts in its own feature branch. When I push code, a pipeline should automatically spin up a *temporary preview* in my testing cluster for isolated testing.
2.  **Merging to `develop`:** Once a feature is approved, it gets merged into the `develop` branch. This should clean up the preview and deploy the changes to the main **Testing Environment** for integration testing.
3.  **Promoting to `main`:** If everything checks out, the final step is to merge `develop` into `main`. This is the trigger to deploy to my **Production Cluster**.

### The Big Question: Will It Work?

This workflow looks solid on paper, but the real test is in the implementation. Will it bring the order and safety I'm looking for, or will it just add another layer of complexity?

I'll be sharing my progress, the hurdles I encounter, and the lessons I learn along the way. Wish me luck, and I hope you'll follow along on this little adventure!

Happy labbing!

<script type="module">
	import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
	mermaid.initialize({
		startOnLoad: true,
		theme: 'base'
	});
</script>